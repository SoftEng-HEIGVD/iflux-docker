\section{Introduction}

While there is no single definition for the term \emph{Smart City} \cite{caragliu2011smart,batty2012smart,shapiro2006smart}, the general idea is that ICT technologies can contribute to improve the quality of life by impacting a wide range of domains: energy, transport, safety, administration, politics, culture, etc. Because of this broad definition, very different types of applications and technologies fit in the scope of smart cities. Think of a sensor network that measures air quality. Think of an application that optimizes public transportation usage by giving incentives to travel outside peak hours. Think of services that encourage citizen to interact more actively and directly with authorities. These are only a few examples that illustrate the variety of smart city applications. Some of these applications have a strong physical dimension, when sensors and actuators are material artifacts (smart objects). Other applications have a lesser physical dimension, when the sensors and the actuators are actually software systems (e.g. mobile applications, online business services). In this paper, we consider the entire spectrum between these two cases.

Cities do not become \emph{smart} overnight. Rather, they become smarter through an evolutionary process. New technologies and applications are introduced over a long period of time, often without an overall architecture defined a priori. Every domain of the city is managed as a silo, with its own needs, its own services and its own infrastructure. For this reason, it is often difficult to build cross-domain applications. Think of an application that would seek to optimize energy consumption by continuously adapting street lighting to the current road traffic. While the sensors (on the roads) and the actuators (in the street lights) might actually be deployed, building the application is generally a challenge because the two components live in two silos, isolated because of a mix of organizational, administrative and technical reasons.

This situation is analogous to any significant information system. Hence, it raises the usual questions: what is the best way to integrate heterogenous components deployed across a Smart City? How can we enable developers to create and deploy new services independently, while ensuring that these services can be shared, reused and combined in higher-level workflows and applications? How can we make the integration of legacy services into the new ecosystem as effortless as possible? Over the last decade, the REST architectural style and standard web technologies (HTTP, JSON, etc.) have proven to be very effective in this pursuit. Combined with the exponential growth of the Internet of Things both in consumer and industrial settings, this makes the Web of Things \cite{Guinard2009} an ideal paradigm for designing city-wide services, where there is a mix of hardware and software components.

Adopting the Web of Things as an architectural style for smart city applications, however, does not address all architectural questions. What concrete guidelines should be followed to expose components through REST APIs? What interaction patterns should be used between system components? How can we concretely ease the creation of new urban services? How do we ensure that the interaction with these services in higher-level applications is easy and manageable? It is to investigate such issues that the iFLUX project has been initiated. Our first objective was to propose a programming model, based on WoT principles, that can be applied to build citywide applications. Our second objective was to expose this programming model in a concrete middleware platform and to evaluate it in a series of illustrative applications.

In the remaining sections of this article, we first give more information about the context in which iFLUX has been created and describe the main design objectives associated with this context. We then introduce the iFLUX programming model by describing three core concepts: \emph{event sources}, \emph{action targets} and \emph{rules}. We then present one aspect of the middleware implementation, by describing three main RESTful endpoints. We finally explain how we have evaluated the platform in several applications, some of which have been built by third-party developers.

\subsection{iFLUX on GitHub}

All the work done in the iFLUX project is in Open Source on GitHub. The main repository, which has references to all others, is \url{https://github.com/SoftEng-HEIGVD/iflux-docker}. You will find all the close to far related projects from this one. Read the different readme present in each repository to get specific details.